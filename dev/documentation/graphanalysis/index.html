<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Graph Analysis · Plasmo.jl - Platform for Scalable Modeling and Optimization</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Plasmo.jl - Platform for Scalable Modeling and Optimization</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Introduction</a></li><li><a class="toctext" href="../quickstart/">Quick Start</a></li><li><a class="toctext" href="../modelgraph/">ModelGraph</a></li><li class="current"><a class="toctext" href>Graph Analysis</a><ul class="internal"><li><a class="toctext" href="#Partitioning-1">Partitioning</a></li><li><a class="toctext" href="#Community-Detection-1">Community Detection</a></li><li><a class="toctext" href="#Methods-1">Methods</a></li></ul></li><li><a class="toctext" href="../solvers/solvers/">Solvers</a></li><li><a class="toctext" href="../../tutorials/tutorials/">Tutorials</a></li><li><a class="toctext" href="../../low_level/baseplasmograph/">Low-Level Functions</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Graph Analysis</a></li></ul><a class="edit-page" href="https://github.com/jalving/Plasmo.jl/blob/master/docs/src/documentation/graphanalysis.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Graph Analysis</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="ModelGraph-Analysis-1" href="#ModelGraph-Analysis-1">ModelGraph Analysis</a></h1><p>A <code>ModelGraph</code> supports graph analysis functions such as graph partitioning or community detection.  The graph analysis functions are particularly useful for creating decompositions of optimization problems and in fact, this is what is done to use Plasmo&#39;s built-in structure-based solvers.</p><h2><a class="nav-anchor" id="Partitioning-1" href="#Partitioning-1">Partitioning</a></h2><p>Graph partitioning can be performed on a <code>ModelGraph</code> using <code>Metis.partition</code>.  The function requires a working Metis interface, which can be cloned with:</p><pre><code class="language-julia">using Pkg
Pkg.clone(&quot;https://github.com/jalving/Metis.jl.git&quot;)</code></pre><p>Once Metis is installed, graph partitions can be obtained like following:</p><pre><code class="language-julia">using Metis
#Assuming we have a ModelGraph
partitions = Metis.partition(graph,4,alg = :KWAY)  #Use the Metis KWAY partition</code></pre><p>where <code>partitions</code> will be a vector of vectors.  Each vector will contain the indices of the nodes in <code>graph</code>.  Partitions can be used to communicate structure to <code>PlasmoSolvers</code> or the <code>PipsSolver</code> if <code>PlasmoSolverInterface</code> is installed.</p><h2><a class="nav-anchor" id="Community-Detection-1" href="#Community-Detection-1">Community Detection</a></h2><p>Graph community detection algorithms can also be used to generate graph partitions, although they do not necessarily return partitions of a selected size.   The current supported community detection algorithms are as follows:</p><h3><a class="nav-anchor" id="Label-propagation-1" href="#Label-propagation-1">Label propagation</a></h3><pre><code class="language-julia">using LightGraphs
communities = LightGraphs.label_propagation(graph)</code></pre><h3><a class="nav-anchor" id="Bethe-Hessian-1" href="#Bethe-Hessian-1">Bethe Hessian</a></h3><pre><code class="language-julia">using CommunityDetection
communities = CommunityDetection.community_detection_bethe(graph)</code></pre><h3><a class="nav-anchor" id="Louvain-Fast-Unfolding-Algorithm-1" href="#Louvain-Fast-Unfolding-Algorithm-1">Louvain Fast Unfolding Algorithm</a></h3><p>For now, you will need to clone a forked version of the CommunityDetection.jl package to use the fast unfolding algorithm.</p><pre><code class="language-julia">using Pkg
Pkg.clone(&quot;https://github.com/jalving/CommunityDetection.jl.git&quot;)
using CommunityDetection
communities = CommunityDetection.community_detection_louvain(graph)</code></pre><h2><a class="nav-anchor" id="Methods-1" href="#Methods-1">Methods</a></h2><pre><code class="language-none">Metis.partition(graph::ModelGraph,n_parts::Int64)
LightGraphs.label_propagation(graph::ModelGraph)
CommunityDetection.community_detection_nback
CommunityDetection.community_detection_bethe
CommunityDetection.community_detection_louvain</code></pre><footer><hr/><a class="previous" href="../modelgraph/"><span class="direction">Previous</span><span class="title">ModelGraph</span></a><a class="next" href="../solvers/solvers/"><span class="direction">Next</span><span class="title">Solvers</span></a></footer></article></body></html>
